// TODO: brancher Postgres + Prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  passwordHash String
  name      String?  // Conservé pour rétrocompatibilité
  coachName String   // Nom de coach (obligatoire)
  firstName String?  // Prénom (optionnel)
  lastName  String?  // Nom (optionnel)
  dateOfBirth DateTime? // Date de naissance (optionnel)
  role      String   @default("user")
  patreon   Boolean  @default(false)
  valid     Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  matches   Match[]
  createdMatches Match[] @relation("MatchCreator")
  teams     Team[]
  teamSelections TeamSelection[]
  createdCups Cup[] @relation("CupCreator")
}

model Match {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  status    String
  seed      String
  creator    User?   @relation("MatchCreator", fields: [creatorId], references: [id])
  creatorId  String?
  players   User[]
  turns     Turn[]
  teamSelections TeamSelection[]
}

model Turn {
  id        String   @id @default(cuid())
  match     Match    @relation(fields: [matchId], references: [id])
  matchId   String
  number    Int
  payload   Json
  createdAt DateTime @default(now())
}

model TeamSelection {
  id        String   @id @default(cuid())
  match     Match    @relation(fields: [matchId], references: [id])
  matchId   String
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  team      String   @default("")
  teamRef   Team?    @relation(fields: [teamId], references: [id])
  teamId    String?
  createdAt DateTime @default(now())

  @@unique([matchId, userId])
  @@unique([matchId, team])
  @@unique([matchId, teamId])
}

model Team {
  id        String   @id @default(cuid())
  owner     User     @relation(fields: [ownerId], references: [id])
  ownerId   String
  name      String
  roster    String   // 'skaven' | 'lizardmen'
  createdAt DateTime @default(now())
  players   TeamPlayer[]
  starPlayers TeamStarPlayer[]
  selections TeamSelection[]
  cupParticipants CupParticipant[]

  // Informations d'équipe Blood Bowl
  treasury      Int @default(0)        // Trésorerie en pièces d'or (calculée automatiquement)
  rerolls       Int @default(0)        // Nombre de relances (0-8)
  cheerleaders  Int @default(0)        // Nombre de cheerleaders (0-12)
  assistants    Int @default(0)        // Nombre d'assistants (0-6)
  apothecary    Boolean @default(false) // Présence d'un apothicaire
  dedicatedFans Int @default(1)        // Nombre de fans dévoués (1-6)

  // Valeurs calculées automatiquement selon les règles Blood Bowl
  teamValue     Int @default(0)        // VE - Valeur d'Équipe (calculée)
  currentValue  Int @default(0)        // VEA - Valeur d'Équipe Actuelle (calculée)
  initialBudget Int @default(0)        // Budget initial saisi par l'utilisateur lors de la création
}

model TeamPlayer {
  id        String   @id @default(cuid())
  team      Team     @relation(fields: [teamId], references: [id])
  teamId    String
  name      String
  position  String
  number    Int
  ma        Int
  st        Int
  ag        Int
  pa        Int
  av        Int
  skills    String
}

model TeamStarPlayer {
  id            String   @id @default(cuid())
  team          Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId        String
  starPlayerSlug String  // Slug du Star Player (ex: 'griff_oberwald')
  cost          Int      // Coût en po au moment du recrutement
  hiredAt       DateTime @default(now())
  
  @@unique([teamId, starPlayerSlug]) // Un même Star Player ne peut être recruté qu'une fois par équipe
  @@index([teamId])
}

// Modèle pour les compétences (skills)
model Skill {
  id          String   @id @default(cuid())
  slug        String   @unique // Identifiant unique (ex: "block", "dodge")
  nameFr      String   // Nom français (ex: "Blocage")
  nameEn      String   // Nom anglais (ex: "Block")
  description String   // Description française de la compétence
  descriptionEn String? // Description anglaise de la compétence (optionnelle pour compatibilité)
  category    String   // "General" | "Agility" | "Strength" | "Passing" | "Mutation" | "Trait"
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  positionSkills    PositionSkill[]
  starPlayerSkills  StarPlayerSkill[]
}

// Modèle pour les rosters d'équipes
model Roster {
  id          String   @id @default(cuid())
  slug        String   @unique // Identifiant unique (ex: "skaven", "lizardmen")
  name        String   // Nom d'affichage en français (ex: "Skavens")
  nameEn      String   // Nom d'affichage en anglais (ex: "Skaven")
  budget      Int      // Budget de départ en kpo
  tier        String   // "I" | "II" | "III"
  naf         Boolean  @default(false) // Disponible dans NAF
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  positions     Position[]
  hirableBy     StarPlayerHirableBy[] // Règles régionales qui peuvent recruter des star players
}

// Modèle pour les positions dans les rosters
model Position {
  id          String   @id @default(cuid())
  roster      Roster   @relation(fields: [rosterId], references: [id], onDelete: Cascade)
  rosterId    String
  slug        String   // Slug unique (ex: "skaven_lineman")
  displayName String   // Nom d'affichage (ex: "Lineman")
  cost        Int      // Coût en kpo
  min         Int      // Minimum requis
  max         Int      // Maximum autorisé
  ma          Int      // Movement Allowance
  st          Int      // Strength
  ag          Int      // Agility
  pa          Int      // Passing
  av          Int      // Armour Value
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  skills      PositionSkill[]
  
  @@unique([rosterId, slug])
  @@index([rosterId])
}

// Relation many-to-many entre Position et Skill
model PositionSkill {
  id         String   @id @default(cuid())
  position   Position @relation(fields: [positionId], references: [id], onDelete: Cascade)
  positionId String
  skill      Skill    @relation(fields: [skillId], references: [id], onDelete: Cascade)
  skillId    String
  
  @@unique([positionId, skillId])
  @@index([positionId])
  @@index([skillId])
}

// Modèle pour les Star Players
model StarPlayer {
  id          String   @id @default(cuid())
  slug        String   @unique // Identifiant unique (ex: "griff_oberwald")
  displayName String   // Nom d'affichage
  cost        Int      // Coût en po (pièces d'or)
  ma          Int      // Movement Allowance
  st          Int      // Strength
  ag          Int      // Agility (valeur cible, ex: 3 pour 3+)
  pa          Int?     // Passing (valeur cible, ex: 2 pour 2+, null pour -)
  av          Int      // Armour Value (valeur cible, ex: 9 pour 9+)
  specialRule String? // Règle spéciale du joueur
  imageUrl    String? // URL de l'image du joueur
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  skills      StarPlayerSkill[]
  hirableBy   StarPlayerHirableBy[]
}

// Relation many-to-many entre StarPlayer et Skill
model StarPlayerSkill {
  id          String     @id @default(cuid())
  starPlayer  StarPlayer @relation(fields: [starPlayerId], references: [id], onDelete: Cascade)
  starPlayerId String
  skill       Skill      @relation(fields: [skillId], references: [id], onDelete: Cascade)
  skillId     String
  
  @@unique([starPlayerId, skillId])
  @@index([starPlayerId])
  @@index([skillId])
}

// Relation many-to-many entre StarPlayer et Roster (pour les règles régionales)
model StarPlayerHirableBy {
  id          String     @id @default(cuid())
  starPlayer  StarPlayer @relation(fields: [starPlayerId], references: [id], onDelete: Cascade)
  starPlayerId String
  roster      Roster?    @relation(fields: [rosterId], references: [id], onDelete: Cascade)
  rosterId    String?
  rule        String     // Règle régionale (ex: "all", "old_world_classic", etc.)
  
  @@unique([starPlayerId, rosterId, rule])
  @@index([starPlayerId])
  @@index([rosterId])
  @@index([rule])
}

// Modèle pour les coupes (tournois)
model Cup {
  id        String   @id @default(cuid())
  name      String   // Nom de la coupe (obligatoire)
  creator   User     @relation("CupCreator", fields: [creatorId], references: [id])
  creatorId String
  validated Boolean  @default(false) // Si true, la coupe est validée et fermée aux inscriptions
  isPublic  Boolean  @default(true)  // Si true, la coupe est publique et apparaît dans la liste
  status    String   @default("ouverte") // Statut: "ouverte", "en_cours", "terminee", "archivee"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  participants CupParticipant[]
  
  @@index([creatorId])
  @@index([validated])
  @@index([isPublic])
  @@index([status])
}

// Relation many-to-many entre Cup et Team (participants)
model CupParticipant {
  id        String   @id @default(cuid())
  cup       Cup      @relation(fields: [cupId], references: [id], onDelete: Cascade)
  cupId     String
  team      Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId    String
  createdAt DateTime @default(now())
  
  @@unique([cupId, teamId])
  @@index([cupId])
  @@index([teamId])
}
