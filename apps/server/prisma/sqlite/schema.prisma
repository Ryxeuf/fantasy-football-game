generator client {
  provider = "prisma-client-js"
  output   = "../../src/prisma-sqlite-client"
}

datasource db {
  provider = "sqlite"
  url      = env("TEST_DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  passwordHash String
  name      String?  // Conservé pour rétrocompatibilité
  coachName String   // Nom de coach (obligatoire)
  firstName String?  // Prénom (optionnel)
  lastName  String?  // Nom (optionnel)
  dateOfBirth DateTime? // Date de naissance (optionnel)
  /// Rôle principal (conservé pour compatibilité, ex: "user" | "admin")
  role      String   @default("user")
  /// Liste complète des rôles (stockée en JSON, ex: '["user","admin"]')
  roles     String   @default("[]")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  matches   Match[]
  createdMatches Match[] @relation("MatchCreator")
  teams     Team[]
  teamSelections TeamSelection[]
  createdCups Cup[] @relation("CupCreator")
  createdLocalMatches LocalMatch[] @relation("LocalMatchCreator")
}

model Match {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  status    String
  seed      String
  creator    User?   @relation("MatchCreator", fields: [creatorId], references: [id])
  creatorId  String?
  players   User[]
  turns     Turn[]
  teamSelections TeamSelection[]
}

model Turn {
  id        String   @id @default(cuid())
  match     Match    @relation(fields: [matchId], references: [id])
  matchId   String
  number    Int
  payload   Json
  createdAt DateTime @default(now())
}

model TeamSelection {
  id        String   @id @default(cuid())
  match     Match    @relation(fields: [matchId], references: [id])
  matchId   String
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  team      String?
  teamRef   Team?    @relation(fields: [teamId], references: [id])
  teamId    String?
  createdAt DateTime @default(now())

  @@unique([matchId, userId])
  @@unique([matchId, teamId])
}

model Team {
  id        String   @id @default(cuid())
  owner     User     @relation(fields: [ownerId], references: [id])
  ownerId   String
  name      String
  roster    String
  createdAt DateTime @default(now())
  players   TeamPlayer[]
  selections TeamSelection[]
  cupParticipants CupParticipant[]
  localMatchesAsTeamA LocalMatch[] @relation("LocalMatchTeamA")
  localMatchesAsTeamB LocalMatch[] @relation("LocalMatchTeamB")
  
  // Informations d'équipe Blood Bowl
  treasury      Int @default(0)        // Trésorerie en pièces d'or (calculée automatiquement)
  rerolls       Int @default(0)        // Nombre de relances (0-8)
  cheerleaders  Int @default(0)        // Nombre de cheerleaders (0-12)
  assistants    Int @default(0)        // Nombre d'assistants (0-6)
  apothecary    Boolean @default(false) // Présence d'un apothicaire
  dedicatedFans Int @default(1)        // Nombre de fans dévoués (1-6)

  // Valeurs calculées automatiquement selon les règles Blood Bowl
  teamValue     Int @default(0)        // VE - Valeur d'Équipe (calculée)
  currentValue  Int @default(0)        // VEA - Valeur d'Équipe Actuelle (calculée)
  initialBudget Int @default(0)        // Budget initial saisi par l'utilisateur lors de la création
}

model TeamPlayer {
  id        String   @id @default(cuid())
  team      Team     @relation(fields: [teamId], references: [id])
  teamId    String
  name      String
  position  String
  number    Int
  ma        Int
  st        Int
  ag        Int
  pa        Int
  av        Int
  skills    String
}

// Modèle pour les coupes (tournois)
model Cup {
  id        String   @id @default(cuid())
  name      String   // Nom de la coupe (obligatoire)
  creator   User     @relation("CupCreator", fields: [creatorId], references: [id])
  creatorId String
  validated Boolean  @default(false) // Si true, la coupe est validée et fermée aux inscriptions
  isPublic  Boolean  @default(true)  // Si true, la coupe est publique et apparaît dans la liste
  status    String   @default("ouverte") // Statut: "ouverte", "en_cours", "terminee", "archivee"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  participants CupParticipant[]
  localMatches LocalMatch[]
  
  @@index([creatorId])
  @@index([validated])
  @@index([isPublic])
  @@index([status])
}

// Relation many-to-many entre Cup et Team (participants)
model CupParticipant {
  id        String   @id @default(cuid())
  cup       Cup      @relation(fields: [cupId], references: [id], onDelete: Cascade)
  cupId     String
  team      Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId    String
  createdAt DateTime @default(now())
  
  @@unique([cupId, teamId])
  @@index([cupId])
  @@index([teamId])
}

// Modèle pour les parties offline (Match Local)
model LocalMatch {
  id        String   @id @default(cuid())
  name      String?  // Nom optionnel pour la partie
  status    String   @default("pending") // "pending", "waiting_for_player", "in_progress", "completed", "cancelled"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  startedAt DateTime? // Date de début de la partie
  completedAt DateTime? // Date de fin de la partie
  
  // Créateur de la partie
  creator   User     @relation("LocalMatchCreator", fields: [creatorId], references: [id])
  creatorId String
  
  // Les deux équipes qui s'affrontent
  teamA     Team     @relation("LocalMatchTeamA", fields: [teamAId], references: [id])
  teamAId   String
  teamB     Team?    @relation("LocalMatchTeamB", fields: [teamBId], references: [id], onDelete: SetNull)
  teamBId   String?
  
  // Relation optionnelle avec une coupe
  cup       Cup?     @relation(fields: [cupId], references: [id], onDelete: SetNull)
  cupId     String?
  
  // Lien de partage pour inviter le second joueur
  shareToken String? @unique // Token unique pour le lien de partage
  
  // Validation de participation des propriétaires des équipes
  teamAOwnerValidated Boolean @default(false) // Le propriétaire de l'équipe A a validé sa participation
  teamBOwnerValidated Boolean @default(false) // Le propriétaire de l'équipe B a validé sa participation
  
  // État du jeu sauvegardé (JSON)
  gameState Json?    // État complet du jeu pour reprise
  
  // Résultat du match (optionnel, rempli à la fin)
  scoreTeamA Int?    // Score de l'équipe A
  scoreTeamB Int?    // Score de l'équipe B
  
  // Actions manuelles enregistrées pour le match
  actions LocalMatchAction[]

  @@index([creatorId])
  @@index([teamAId])
  @@index([teamBId])
  @@index([cupId])
  @@index([status])
  @@index([createdAt])
  @@index([shareToken])
}

// Modèle pour les actions manuelles d'un match local
model LocalMatchAction {
  id        String   @id @default(cuid())
  match     LocalMatch @relation(fields: [matchId], references: [id], onDelete: Cascade)
  matchId   String
  
  // Informations sur l'action
  half      Int      // Mi-temps (1 ou 2)
  turn      Int      // Tour (1-8)
  actionType String   // Type d'action: "passe", "reception", "td", "blocage", "blitz", "transmission", "aggression", "sprint", "esquive", "apothicaire", "interception"
  
  // Joueur qui effectue l'action
  playerId  String   // ID du joueur (peut être un ID de joueur de l'équipe A ou B)
  playerName String  // Nom du joueur (pour référence)
  playerTeam String  // "A" ou "B"
  
  // Adversaire concerné (optionnel)
  opponentId String? // ID du joueur adverse (si applicable)
  opponentName String? // Nom du joueur adverse (si applicable)
  
  // Résultat du dé (optionnel)
  diceResult Int?    // Résultat du dé (1-6, ou autre selon le type d'action)
  
  // Échec (fumble)
  fumble     Boolean @default(false) // Si true, l'action a échoué (fumble)
  
  // État du joueur en cas d'échec (sauf pour passe, transmission, réception, apothicaire, interception)
  playerState String? // État du joueur si l'action échoue: "sonne", "ko", "elimine"
  
  // Champs spécifiques pour blitz et blocage
  armorBroken Boolean @default(false) // Si true, l'armure de l'adversaire est passée
  opponentState String? // État de l'adversaire si armure passée: "sonne", "ko", "elimine"
  
  // Champ spécifique pour passe
  passType String? // Type de passe: "rapide", "courte", "longue", "longue_bombe"
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([matchId])
  @@index([half, turn])
  @@index([createdAt])
}


